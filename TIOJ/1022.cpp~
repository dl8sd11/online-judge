#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pii;
#define MEM(i,n) memset(i,n,sizeof i)
#define REP(i,n) for(ll i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define X first
#define Y second
const ll MAXN = 3e3 + 7;
const ll INF = 1e18;
ll k,m,n;
ll h[MAXN][MAXN];
bool visit[MAXN][MAXN];
ll dirX[] = {-1,0,1,0};
ll dirY[] = {0,1,0,-1};
ll mabs(ll x) {return x<0?-x:x;}
int main(){
  cin>>k;
  while (k--) {
    MEM(visit,0);
    cin>>m>>n;
    REP (i,n+2) {
      h[0][i] = INF;
      h[m+1][i] = INF;
    }
    REP (i,m+2) {
      h[i][0] = INF;
      h[i][n+1] = INF;
    }
    REP1 (i,m) REP1(j,n) cin>>h[i][j];
    queue<pii> BFS;
    BFS.push({1,1});
    visit[1][1] = 1;
    ll cnt = 0;
    bool flag=0;
    while (BFS.size()) {
      cout<<"DEBUG "<<cnt<<' '<<BFS.size()<<endl;
      REP (u,(ll)BFS.size()) {
	pii now = BFS.front();BFS.pop();
       	if (now.X==m&&now.Y==n) {
	  cout<<cnt<<endl;
	  flag=1;
	  break;
	}
	cout<<cnt<<' '<<now.X<<' '<<now.Y<<endl;
	REP (i,4) {
	  pii tmp = {now.X+dirX[i],now.Y+dirY[i]};
	  ll tx = tmp.X,ty = tmp.Y;
	  if (visit[tx][ty]||mabs(h[tx][ty]-h[now.X][now.Y])>5)continue;
	  BFS.push({tx,ty});
	  visit[tx][ty]=1;
	}
      }
      if (flag) break;
      cnt++;
    }
  }
}
